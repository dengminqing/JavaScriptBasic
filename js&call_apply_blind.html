<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<title>Examples</title>
<meta name="description" content="">
<meta name="keywords" content="">
<link href="" rel="stylesheet">
</head>
<body>
  <script type="text/javascript">
  	function fruits(){}
  	fruits.prototype ={
		color:"red",
		say: function(){
			document.write("My color is " +this.color+"<br/>");
		}
	}
  	var apple = new fruits;
  	apple.say();

  	//但是如果我们有一个对象banana= {color : “yellow”} ,我们不想对它重新定义 say 方法，那么我们可以通过 call 或 apply 用 apple 的 say 方法：
  	banana = {
  		color:'yellow'
  	}
  	apple.say.call(banana);
  	apple.say.apply(banana)

  	//所以，可以看出 call 和 apply 是为了动态改变 this 而出现的，当一个 object 没有某个方法（本例子中banana没有say方法），但是其他的有（本例子中apple有say方法），我们可以借助call或apply用其它对象的方法来操作。


  	/*
		区别
  	*/ 
  	var array1 = [12,"f00",1212]
  	var array2 = ["Doe",555,100];
  	Array.prototype.push.apply(array1,array2);
  	console.log(array1)//[12, "f00", 1212, "Doe", 555, 100] 
  	console.log(array2)//["Doe", 555, 100] 

  	//获取数组中的最大值和最小值
  	var  numbers = [5, 458 , 120 , -215 ]; 
	var maxInNumbers = Math.max.apply(Math, numbers),  //458
    	maxInNumberss = Math.max.call(Math,5, 458 , 120 , -215); //458
    document.write(maxInNumbers+"<br/>");
    document.write(maxInNumberss);

    function isArray(obj){
    	return Object.prototype.toString.call(obj) === '[object Array]';
    }
    console.log(isArray(array1))

    function log(){
	  console.log.apply(console, arguments);
	};
	log(1);    //1
	log(1,2);    //1 2

	function log2(){
	  var args = Array.prototype.slice.call(arguments);
	  args.unshift('(app)');

	  console.log.apply(console, args);
	};
	log(1,2,3); 
  </script>  
</body>
</html>